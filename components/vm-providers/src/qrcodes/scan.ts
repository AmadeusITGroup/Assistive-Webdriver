/*
 * Copyright 2021 Amadeus s.a.s.
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import type { PNG } from "pngjs";
import {
  RGBLuminanceSource,
  BinaryBitmap,
  HybridBinarizer,
  QRCodeReader,
  DecodeHintType,
  ResultPoint,
  ResultPointCallback,
  Result
} from "@zxing/library";
import { CalibrationQRCodesConfig } from "./config";
import { SimplePosition } from "../vm/vmInterface";

/**
 * Contains the position and size of a rectangle on the screen.
 * @public
 */
export interface Rectangle extends SimplePosition {
  /** Width (in pixels) of the rectangle. */
  width: number;
  /** Height (in pixels) of the rectangle. */
  height: number;
}

/**
 * Calibration image scan result, as returned by {@link calibrationQRCodesScan}.
 * @public
 */
export interface CalibrationQRCodesScanResult {
  /**
   * Position of the top left corner of the calibration image
   * inside the full image.
   */
  viewport: SimplePosition;

  /**
   * Position and size of a QR code that was successfully scanned, inside
   * the full image.
   */
  qrCode: Rectangle;
}

const resultRegExp = /^(\d+),(\d+)$/;

const processResult = (
  res: Result,
  extraX: number,
  extraY: number,
  prefix: string,
  scale: number
): CalibrationQRCodesScanResult => {
  const text = res.getText();
  const match = text.startsWith(prefix)
    ? resultRegExp.exec(text.substring(prefix.length))
    : null;
  if (match) {
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    res.getResultPoints().forEach(function (point) {
      const x = extraX + point.getX();
      const y = extraY + point.getY();
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    });
    minX = Math.floor(minX - 3.5 * scale);
    minY = Math.floor(minY - 3.5 * scale);
    maxX = Math.floor(maxX + 3.5 * scale);
    maxY = Math.floor(maxY + 3.5 * scale);
    const x = +match[1];
    const y = +match[2];
    return {
      viewport: {
        x: minX - x,
        y: minY - y
      },
      qrCode: {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      }
    };
  } else {
    throw new Error(`Unexpected QR code containing: ${text}`);
  }
};

/**
 * Scans an image containing a calibration image (which can be generated by
 * {@link calibrationQRCodesGenerate}) and returns its position and the position
 * of the QR code that was successfully scanned.
 *
 * @param image - full image containing a calibration image
 * @param config - configuration used when generating the calibration image
 * @returns the position of the calibration image inside the full image, and the position and size
 * of the QR code that was successfully scanned.
 * @public
 */
export function calibrationQRCodesScan(
  image: PNG,
  config: CalibrationQRCodesConfig = {}
): CalibrationQRCodesScanResult {
  const {
    scale = 1,
    innerMargin = 50 * scale,
    contentPrefix = "viewport://"
  } = config;
  const size = image.width * image.height;
  const luminancesUint8Array = new Uint8ClampedArray(size);
  for (let offset = 0; offset < size; offset++) {
    const r = image.data[offset * 4];
    const g = image.data[offset * 4 + 1];
    const b = image.data[offset * 4 + 2];
    luminancesUint8Array[offset] = ((r + g + b) / 3) & 0xff;
  }
  const luminanceSource = new RGBLuminanceSource(
    luminancesUint8Array,
    image.width,
    image.height
  );
  const binaryBitmap = new BinaryBitmap(new HybridBinarizer(luminanceSource));
  const reader = new QRCodeReader();
  const hints = new Map();
  const possibleResultPoints: ResultPoint[] = [];
  hints.set(DecodeHintType.TRY_HARDER, true);
  const callback: ResultPointCallback = {
    foundPossibleResultPoint(point) {
      if ((point as any).estimatedModuleSize === scale) {
        possibleResultPoints.push(point);
      }
    }
  };
  hints.set(DecodeHintType.NEED_RESULT_POINT_CALLBACK, callback);
  try {
    return processResult(
      reader.decode(binaryBitmap, hints),
      0,
      0,
      contentPrefix,
      scale
    );
  } catch (error) {
    // the QR code reader may not find any result because it gets confused with the multiple QR codes
    // let's try again after cropping around each result point:
    for (const point of possibleResultPoints) {
      try {
        const x1 = Math.max(0, Math.floor(point.getX() - innerMargin));
        const y1 = Math.max(0, Math.floor(point.getY() - innerMargin));
        const x2 = Math.min(
          image.width,
          Math.floor(point.getX() + innerMargin)
        );
        const y2 = Math.min(
          image.height,
          Math.floor(point.getY() + innerMargin)
        );
        return processResult(
          reader.decode(binaryBitmap.crop(x1, y1, x2 - x1, y2 - y1)),
          x1,
          y1,
          contentPrefix,
          scale
        );
      } catch (error) {
        // ignore errors
      }
    }
    throw error;
  }
}
